---
phase: 01-eslint
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - api/package.json
  - eslint.config.js
autonomous: true

must_haves:
  truths:
    - 'ESLint binary is available in both root and api/ directories'
    - 'ESLint config exists at project root with rules for both frontend and backend'
    - 'Developer can run npm run lint from root or api/ directory'
  artifacts:
    - path: 'eslint.config.js'
      provides: 'Flat config with cascading frontend/backend rules'
      min_lines: 150
      contains: 'export default'
    - path: 'package.json'
      provides: 'Frontend ESLint dependencies and lint scripts'
      exports: ['eslint', 'typescript-eslint']
    - path: 'api/package.json'
      provides: 'Backend ESLint dependencies and lint scripts'
      exports: ['eslint', 'typescript-eslint']
  key_links:
    - from: 'eslint.config.js'
      to: 'tsconfig.json + api/tsconfig.json'
      via: 'parserOptions.project'
      pattern: "project:.*tsconfig\\.json"
    - from: 'package.json scripts'
      to: 'eslint binary'
      via: 'npm run lint'
      pattern: '"lint".*eslint'
---

<objective>
Configure ESLint 9 with flat config for TypeScript monorepo, installing all dependencies and creating a single root configuration that handles both React frontend and Fastify backend with appropriate rules for each.

**Purpose:** Establish linting infrastructure that understands TypeScript + React JSX in frontend, and TypeScript + Node/ESM in backend, respecting existing code conventions (semicolons, single quotes, 2 spaces, trailing commas).

**Output:** Complete ESLint setup ready for code scanning — all dependencies installed, config file created, npm scripts added.
</objective>

<execution_context>
@/home/mvrdu/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/mvrdu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-eslint/01-CONTEXT.md
@.planning/phases/01-eslint/01-RESEARCH.md
@.planning/codebase/STACK.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/STRUCTURE.md
@.planning/codebase/CONVENTIONS.md
@package.json
@api/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install ESLint dependencies in both packages</name>
  <files>
    package.json
    api/package.json
    package-lock.json
  </files>
  <action>
Install ESLint 9 and related dependencies in both root (frontend) and api/ (backend) packages.

**Root package (frontend):**

```bash
npm install --save-dev eslint@^9.18.0 @eslint/js@^9.18.0 typescript-eslint@^8.55.0 globals@^15.14.0 eslint-plugin-react@^7.37.0 eslint-plugin-react-hooks@^5.1.0 eslint-plugin-import@^2.32.0 eslint-import-resolver-typescript@^3.8.0
```

**Backend package (api/):**

```bash
npm install --save-dev eslint@^9.18.0 @eslint/js@^9.18.0 typescript-eslint@^8.55.0 globals@^15.14.0 eslint-plugin-import@^2.32.0 eslint-import-resolver-typescript@^3.8.0
```

**Rationale:**

- ESLint 9 with flat config is the current standard (2026)
- `typescript-eslint` unified package replaces old split packages
- Both packages need ESLint binary for editor support
- Frontend gets React plugins, backend doesn't
- Import plugin handles module resolution and `.js` extension requirement
  </action>
  <verify>
  Check that dependencies appear in both package.json devDependencies:

```bash
grep -A 10 '"devDependencies"' package.json | grep eslint
grep -A 10 '"devDependencies"' api/package.json | grep eslint
```

  </verify>
  <done>
- Root package.json contains eslint, @eslint/js, typescript-eslint, globals, react plugins, import plugin
- api/package.json contains eslint, @eslint/js, typescript-eslint, globals, import plugin
- package-lock.json updated with new dependencies
  </done>
</task>

<task type="auto">
  <name>Task 2: Create root eslint.config.js with cascading monorepo config</name>
  <files>
    eslint.config.js
  </files>
  <action>
Create `eslint.config.js` at project root using ESM flat config format with separate configuration objects for frontend and backend.

**Structure:**

1. Global ignores (dist, node_modules, build)
2. Base ESLint recommended config
3. Frontend config object (files: **/\*.{js,jsx,ts,tsx}, ignores: api/**)
4. Backend config object (files: api/\*_/_.{js,ts})

**Frontend config:**

- Parser: typescript-eslint
- Plugins: @typescript-eslint, react, react-hooks, import
- Extends: typescript-eslint recommended, react recommended, react jsx-runtime
- Globals: browser
- Rules:
  - Existing conventions: semi: always, quotes: single, indent: 2, comma-dangle: always-multiline, arrow-parens: always
  - TypeScript: no-unused-vars (error, ignore ^\_), no-explicit-any (warn)
  - React: prop-types off, react-in-jsx-scope off, hooks rules
  - Import: extensions never for .js/.jsx/.ts/.tsx, order by groups, no-unresolved error
- Settings: react version detect, import resolver typescript

**Backend config:**

- Parser: typescript-eslint with project: ./api/tsconfig.json
- Plugins: @typescript-eslint, import
- Extends: typescript-eslint strictTypeChecked
- Globals: node
- Rules:
  - Same conventions as frontend
  - TypeScript: no-explicit-any error (stricter)
  - Import: extensions always for .js (NodeNext requirement), ts never, ignorePackages true
  - Import: order by groups, no-unresolved error
- Settings: import resolver typescript with api/tsconfig.json

**Use research patterns from 01-RESEARCH.md code examples (lines 464-647).**

**Critical:**

- Backend MUST have `import/extensions: ['error', 'always', { js: 'always', ts: 'never', ignorePackages: true }]` because it uses `moduleResolution: "NodeNext"`
- Frontend MUST have `import/extensions: ['error', 'never', ...]` because it uses `moduleResolution: "bundler"`
- Use ESM syntax (import/export default), not CommonJS
- React 17+ doesn't need React in scope (jsx-runtime)
  </action>
  <verify>

```bash
# Config file exists and is valid ESM
node -e "import('./eslint.config.js').then(() => console.log('✓ Valid ESM config'))"

# Config exports an array
node -e "import('./eslint.config.js').then(m => console.log('Config type:', Array.isArray(m.default) ? 'array ✓' : typeof m.default))"

# Contains both frontend and backend rules
grep -q "files.*tsx" eslint.config.js && echo "✓ Frontend config present"
grep -q "files.*api" eslint.config.js && echo "✓ Backend config present"
grep -q "import/extensions.*always" eslint.config.js && echo "✓ Backend .js extension rule present"
```

  </verify>
  <done>
- eslint.config.js exists at project root
- File is valid ESM (exports default array)
- Contains global ignores for dist, node_modules, build
- Contains frontend config object targeting root files, excluding api/
- Contains backend config object targeting api/ files
- Frontend config has React plugins and no extension requirement
- Backend config has .js extension requirement for NodeNext
- Both configs respect existing conventions (semi, quotes, indent, comma-dangle, arrow-parens)
  </done>
</task>

<task type="auto">
  <name>Task 3: Add lint scripts to package.json files</name>
  <files>
    package.json
    api/package.json
  </files>
  <action>
Add npm scripts for running ESLint in both packages.

**Root package.json** (add to "scripts" section):

```json
"lint": "eslint .",
"lint:fix": "eslint . --fix",
"lint:frontend": "eslint --ignore-pattern 'api/**' .",
"lint:backend": "eslint api/"
```

**api/package.json** (add to "scripts" section):

```json
"lint": "eslint .",
"lint:fix": "eslint . --fix"
```

**Note:** Root scripts can lint entire project or specific parts. Backend scripts run from api/ directory and lint api/ files using root config.
</action>
<verify>

```bash
# Scripts exist in both files
npm run | grep lint
cd api && npm run | grep lint && cd ..

# Dry-run to confirm scripts work (will show errors, that's expected)
npm run lint -- --max-warnings=999 --no-exit-on-fatal-error 2>&1 | head -n 5
```

  </verify>
  <done>
- Root package.json has lint, lint:fix, lint:frontend, lint:backend scripts
- api/package.json has lint, lint:fix scripts
- Running `npm run lint` from root executes eslint on entire project
- Running `npm run lint` from api/ executes eslint on backend files
- Scripts use root eslint.config.js (cascading works)
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
# 1. Dependencies installed in both packages
ls node_modules/eslint && ls api/node_modules/eslint

# 2. Config file is syntactically valid
node -e "import('./eslint.config.js').then(() => console.log('Config loads successfully'))"

# 3. Scripts are callable
npm run lint -- --help | grep -q "eslint" && echo "Root lint script works"
cd api && npm run lint -- --help | grep -q "eslint" && echo "Backend lint script works" && cd ..

# 4. Config recognizes both frontend and backend files
npm run lint 2>&1 | grep -E "(Linting complete|error|warning)" | head -n 1
```

Expected: ESLint runs without config errors. May report code errors (expected for brownfield codebase). No "Config not found" or "Parser error" messages.
</verification>

<success_criteria>
**Measurable completion:**

1. **Dependencies installed:** `ls node_modules/eslint && ls api/node_modules/eslint` succeed
2. **Config exists and is valid:** `node -e "import('./eslint.config.js').then(console.log)"` succeeds
3. **Scripts callable:** `npm run lint` and `cd api && npm run lint` both execute ESLint
4. **Config recognizes TypeScript:** Running lint on .ts/.tsx files doesn't report parser errors
5. **Frontend/backend separation works:** Config applies React rules to frontend, Node rules to backend
6. **Ready for next plan:** ESLint infrastructure complete, ready to run auto-fix and manual fixes

**User can confirm:** Run `npm run lint` and see ESLint scanning files (errors expected, but no config/parser failures).
</success_criteria>

<output>
After completion, create `.planning/phases/01-eslint/01-01-SUMMARY.md` containing:

- Dependencies installed (which packages, where)
- Config structure (how frontend/backend are separated)
- Key rules configured (import extensions, conventions)
- Scripts added (what they do)
- Any issues encountered during setup
- Current state: ESLint ready to scan, next plan will fix violations
  </output>
