---
phase: 01-eslint
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - "**/*.ts"
  - "**/*.tsx"
  - "**/*.js"
  - "**/*.jsx"
  - api/**/*.ts
  - api/**/*.js
autonomous: true

must_haves:
  truths:
    - "Running npm run lint reports zero errors"
    - "ESLint catches unused variables and undefined references"
    - "ESLint respects existing code conventions (semicolons, single quotes, 2 spaces)"
    - "Backend imports use .js extensions where required"
    - "Frontend imports don't use extensions"
  artifacts:
    - path: "all TypeScript and JavaScript files"
      provides: "Clean code passing all ESLint rules"
      contains: "no lint errors"
  key_links:
    - from: "all source files"
      to: "eslint.config.js rules"
      via: "lint compliance"
      pattern: "zero errors in npm run lint output"
---

<objective>
Achieve zero ESLint errors across the entire codebase by running auto-fix first, then manually resolving remaining violations, prioritizing potential bugs over style issues.

**Purpose:** Deliver a clean baseline where all code passes linting rules, with proper import extensions in backend, no unused variables, and no undefined references. User's locked decision: single atomic commit containing config + auto-fixes + manual fixes.

**Output:** Brownfield codebase fully compliant with ESLint rules, ready for Phase 2 (Prettier integration).
</objective>

<execution_context>
@/home/mvrdu/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/mvrdu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-eslint/01-CONTEXT.md
@.planning/phases/01-eslint/01-RESEARCH.md
@.planning/phases/01-eslint/01-01-SUMMARY.md
@eslint.config.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Run eslint --fix to auto-correct violations</name>
  <files>
    (All .ts, .tsx, .js, .jsx files in project)
  </files>
  <action>
Run ESLint's auto-fix across the entire project to automatically correct fixable violations.

```bash
npm run lint:fix
```

**What auto-fix handles:**
- Missing semicolons → adds them
- Double quotes → converts to single quotes
- Inconsistent spacing → normalizes to 2 spaces
- Missing trailing commas → adds them
- Incorrect arrow function parens → adds/removes as needed
- Import ordering → reorders import statements
- Some unused imports → removes them

**What auto-fix CANNOT handle (requires manual):**
- Unused variables (declarations that need removal or usage)
- No-undef errors (undefined references)
- Complex type issues
- Missing `.js` extensions in backend imports (if tool doesn't add them automatically)

**Expected:** Many files will be modified. Capture the output to understand what remains.

Save the post-auto-fix lint report:
```bash
npm run lint > .planning/phases/01-eslint/post-autofix-report.txt 2>&1 || true
```
  </action>
  <verify>
```bash
# Count remaining errors
npm run lint 2>&1 | grep -E "([0-9]+) error" || echo "No errors reported"

# If errors remain, show summary
npm run lint 2>&1 | tail -n 20
```
  </verify>
  <done>
- Auto-fix ran successfully across all files
- Fixable style issues (quotes, semicolons, spacing) are corrected
- Post-fix report saved showing remaining violations (if any)
- Ready to proceed with manual fixes for remaining errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Manually fix remaining ESLint errors</name>
  <files>
    (Files with remaining errors from Task 1)
  </files>
  <action>
Review the post-autofix report and manually fix all remaining ESLint errors to achieve zero errors.

**Priority order (per user's decision):**
1. **Potential bugs first:**
   - `no-unused-vars` → Remove unused variable declarations or mark with underscore prefix if needed for API contracts
   - `no-undef` → Fix undefined references (add imports, fix typos)
   - `@typescript-eslint/no-unused-vars` → Same as above for TS
   - React hooks violations → Fix dependency arrays
   - `import/no-unresolved` → Fix broken import paths

2. **Import extensions (backend only):**
   - Backend uses `moduleResolution: "NodeNext"` → ALL relative imports MUST have `.js` extension
   - Pattern to fix: `import { foo } from './utils'` → `import { foo } from './utils.js'`
   - Pattern to fix: `import { bar } from '../types'` → `import { bar } from '../types.js'`
   - Frontend should NOT have extensions (already configured in rules)

3. **Style issues (only if blocking):**
   - Type errors that prevent compilation
   - Other errors that block zero-error goal

**Strategy:**
- Work through errors file by file
- Read each file with errors
- Apply fixes using Edit tool
- Re-run `npm run lint` to confirm fixes
- Continue until zero errors

**Critical for backend:** When fixing imports in `api/` directory, ALWAYS add `.js` extension to relative imports. This is not optional — NodeNext requires it.

**Example backend fix:**
```typescript
// Before (ERROR)
import { authenticate } from './hooks/auth';
import { prisma } from './plugins/prisma';

// After (CORRECT)
import { authenticate } from './hooks/auth.js';
import { prisma } from './plugins/prisma.js';
```
  </action>
  <verify>
```bash
# Run full lint check - MUST show zero errors
npm run lint

# Verify no errors in exit code
npm run lint && echo "✓ Zero errors achieved" || echo "✗ Errors still present"

# Double-check backend specifically (often has import issues)
npm run lint:backend && echo "✓ Backend clean" || echo "✗ Backend has errors"
```
  </verify>
  <done>
- All ESLint errors resolved across frontend and backend
- Backend imports have `.js` extensions on all relative imports
- Frontend imports have NO extensions (per bundler resolution)
- No unused variables remain (removed or marked with underscore)
- No undefined references remain (imports added or references fixed)
- `npm run lint` reports 0 errors (warnings acceptable)
- Codebase ready for commit
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify zero errors and commit changes</name>
  <files>
    (All modified files + config)
  </files>
  <action>
Final verification that zero errors are achieved, then create single atomic commit containing config + auto-fixes + manual fixes.

**Verification:**
```bash
# Final lint check - must pass cleanly
npm run lint

# Run TypeScript compiler to ensure no type breakage
npx tsc --noEmit
cd api && npx tsc --noEmit && cd ..

# Check git status to see all changes
git status
```

**Commit:**
```bash
# Stage all changes (config + code fixes)
git add eslint.config.js package.json api/package.json package-lock.json
git add -A  # All code changes from auto-fix and manual fixes

# Single atomic commit per user's decision
git commit -m "feat(dx): configure ESLint 9 for TypeScript monorepo

- Add ESLint 9 with flat config to both frontend and backend
- Install typescript-eslint, React plugins (frontend), import plugin
- Create root eslint.config.js with cascading configs
- Frontend: React + TypeScript rules, no import extensions
- Backend: Strict TypeScript rules, .js extensions required
- Auto-fix style violations (quotes, semicolons, spacing, imports)
- Manually fix unused vars, undefined refs, import paths
- Achieve zero ESLint errors (warnings acceptable)

Phase: 01-eslint (DX-01, DX-02)
Ref: .planning/phases/01-eslint/"
```

**User's locked decision:** Config + auto-fix + manual fixes in ONE commit (not separate commits).
  </action>
  <verify>
```bash
# Commit created
git log -1 --oneline | grep -q "eslint"

# Working tree clean
git status | grep -q "nothing to commit"

# Lint still passes after commit
npm run lint && echo "✓ Lint passes post-commit"
```
  </verify>
  <done>
- Final lint check shows 0 errors
- TypeScript compilation passes (no type breakage)
- Single atomic commit created with all changes
- Commit message follows conventional commits format
- Working tree is clean
- Phase 1 complete: ESLint configured and codebase clean
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
# 1. Zero errors achieved
npm run lint 2>&1 | grep -E "0 errors"

# 2. TypeScript still compiles
npx tsc --noEmit && echo "Frontend types OK"
cd api && npx tsc --noEmit && echo "Backend types OK" && cd ..

# 3. Backend imports have .js extensions
grep -r "from '\\.\\./.*'" api/src/ | grep -v "\\.js'" && echo "Missing .js extensions found!" || echo "All backend imports have .js ✓"

# 4. Commit exists
git log -1 --oneline | grep eslint

# 5. Config is used
npm run lint -- --debug 2>&1 | grep -q "eslint.config.js" && echo "Config loaded ✓"
```

Expected: All checks pass. Zero ESLint errors, TypeScript compiles, backend has .js extensions, commit exists.
</verification>

<success_criteria>
**Measurable completion:**

1. **Zero errors:** `npm run lint` output contains "0 errors" (warnings allowed)
2. **Backend imports correct:** All relative imports in `api/` have `.js` extensions
3. **Frontend imports correct:** No extensions on imports in root (except package imports)
4. **Types valid:** `tsc --noEmit` passes in both root and api/
5. **Single commit:** Git log shows one commit with config + fixes together
6. **Phase requirements met:**
   - DX-01 (ESLint configured for monorepo) ✓
   - DX-02 (Zero errors in both packages) ✓

**Success Criteria from ROADMAP.md Phase 1:**
1. ✓ Running ESLint on frontend reports real issues or passes clean (no config errors)
2. ✓ Running ESLint on backend reports real issues or passes clean (no config errors)
3. ✓ ESLint rules respect existing conventions (semicolons, single quotes, 2 spaces)
4. ✓ ESLint understands TypeScript and React JSX in frontend, TypeScript and Node/ESM in backend

**User can confirm:** Run `npm run lint` and see "0 errors" in output.
</success_criteria>

<output>
After completion, create `.planning/phases/01-eslint/01-02-SUMMARY.md` containing:

- Auto-fix results (how many files changed, what was fixed)
- Manual fixes applied (categories of errors, specific challenges)
- Backend import fixes (how many files needed .js extensions)
- Final lint results (0 errors, N warnings if any)
- TypeScript compilation status (still passing)
- Commit details (hash, files changed, lines changed)
- Lessons learned (pain points, easy wins)
- Current state: Phase 1 complete, ready for Phase 2 (Prettier)
</output>
